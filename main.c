#define _CRT_SECURE_NO_WARNINGS 1//或者将报错的4996给屏蔽了，#pragma warning(disable:4996)
#include <stdio.h>


//《关键字深度剖析 - 解开程序员面试笔试的秘密》这本书

//关键字深度剖析



//关键字 - 第一讲
 //课程目标
   //初步了解关键字的分类
   //深刻理解变量
   //深刻理解定义与声明
   //auto关键字的理解
   //站在存储结构角度，理解register

//关键字分类
  //C语言一共多少个关键字？ 一般书上都是32个关键字，这是C90(C89)的标准，其实C99后，又新增5个
  //关键字


//      关键字                               说明
//       auto                             声明自动变量
//       short                            声明短整型变量或函数
//       int                              声明整型变量或函数
//       long                             声明长整型变量或函数
//       float                            声明浮点型变量或函数
//       double                           声明双精度变量或函数
//       char                             声明字符型变量或函数
//       struct                           声明结构体变量或函数
//       union                            声明共用数据类型（联合体）
//       enum                             声明枚举类型
//       typedef                          用以给数据类型取别名
//       const                            声明只读变量
//       unsigned                         声明无符号类型变量或函数
//       signed                           声明有符号类型变量或函数
//       extern                           声明变量是在其他文件正声明
//       register                         声明寄存器变量
//       static                           声明静态变量
//       volatile                         说明变量在程序执行中可被隐含地改变
//       void                             声明函数无返回值或无参数，声明无类型指针
//       if                               条件语句
//       else                             条件语句否定分支（与if连用）
//       switch                           用于开关语句
//       case                             开关语句分支
//       for                              一种循环语句
//       do                               循环语句的循环体
//       while                            循环语句的循环条件
//       goto                             无条件跳转语句
//       continue                         结束当前循环，开始下一轮循环
//       break                            跳出当前循环
//       default                          开关语句中的“其他”分支
//       sizeof                           计算数据类型的大小
//       return                           子程序返回语句（可以带参数，也可以不带参数）循环条件


//const        static      volatile   是在面试中经常会被问到的


//#include <windows.h>//window.h系统头文件，仅仅是为了停屏
//int main()
//{
//	printf("hello world!\n");
//	system("pause");//pause停屏，会用就行
//	return 0;
//}

//调试： 是将文本代码 ->可执行程序(应用程序，可执行文件) ->在windows当中双击就可以进行运行 
                      //是二进制文件 
//生成 中 清理解决方案就会将一些文件给清除了，生成之后，又可以将这些文件生成回来


//1、在win当中，双击的本质运行程序，将程序加载到内存当中
//2、任何程序在被运行之前都必须被加载到内存当中
          //未被加载之前是在硬盘当中（外存）
          //加载之后，为什么加载到内存中呢？
//冯诺依曼体系结构：数据先在硬盘之中，之后加载到内存当中，从内存到CPU读取之后再返回内存当中
  //最后从内存到输出设备之中（显示器等）（偏硬件）
//为啥要把数据加载到内存中，原因就是   快


//变量

//1、什么是变量
//2、如何定义变量
//3、为什么要定义变量



//1、所有的变量，本质都是在内存的某个位置开辟空间，具体是什么位置取决于C程序地址空间这样的概念
   //程序在运行的时候才会被开辟的，而程序之后在运行之后才会被加载到内存

//2、类型 变量名 = 默认值
//3、//理解链
       //计算机是为了解决人计算能力不足的问题而诞生的。即，计算机是为了计算的
       //而计算，就需要数据，而要计算，任何一个时刻，不是所有的数据都要立马被计算。
       //换句话说，为何需要变量，因为有数据需要暂时被保存起来，等待后续处理



//变量定义的本质
  //我们现在已知：
   //1、程序运行，需要加载到内存中
   //2、程序计算，需要使用变量
//那么，定义变量的本质：在内存中开辟一块空间，用来保存数据。（为何一定是内存：因为定义变量，
    //也是程序逻辑的一部分，程序已经被加载到内存中）


//定义与声明：
  //定义：本质是开辟空间的，定义只能定义一次（表白对一个人只能表白一次）
  //声明：是一种告知，将其关联起来，声明可以声明多次






//1、最宽宏大量的关键字 - auto

//auto:在缺省情况下，编译器默认局部变量都是auto的。“他是做宽宏大量的，读者就当他不存在吧”！

//局部变量：包含在代码块（{}）中的变量叫做局部变量，局部变量具有临时性。进入代码块，自动形成
  //局部变量，退出代码块自动释放
    //（网上很多说函数中的变量是局部变量，不能说错，但是说法是不准确的）
//全局变量：在所有函数外定义的变量，叫做全局变量。全局变量具有全局性。

//变量的作用域：
  //作用域的概念：指的是该变量的可以被正常访问的代码区域(有效区域)
  //局部变量：只在本代码块内有效
  //全局变量：整个程序运行期间，都有效
  //当全局变量和局部变量名相同的时候，局部变量优先，不建议这么做

//变量的声明周期：
  //生命周期的概念：指的是该变量从定义到被释放的时间范围，所谓的释放，指的是曾经开辟的空间
     //“被释放”
  //局部变量：进入代码块，形成局部变量[开辟空间]，退出代码块，“释放”局部变量
  //全局变量：定义完成之后，程序运行的整个生命周期内，该变量一直有效


//auto关键字
  //如何使用：一般在代码块中定义的变量，即局部变量，默认都是auto修饰的，不过一般省略
  // 默认的所有变量都是auto吗？不是，一般来修饰局部变量的
//中断一下：后面我们所讲到的，局部变量，自动变量，临时变量，都是一回事。我们统统称局部变量

//int main()
//{
//    for (int i = 0; i < 10; i++)
//    {
//        //这样定义的话就只能在这对代码块中有效
//    }
//    printf("%d\n", i);
//    return 0;
//}

//auto int g_val = 200;//虽然能编译过去，但是是有问题的这里的auto说明了g_val是全局变量，auto
//                      //不能修饰全局变量
//
//int main()
//{
//    //for (int i = 0; i < 10; i++)
//    for (auto int i = 0; i < 10; i++)
//    {
//        printf("i = %d\n", i);
//        if (1)
//        {
//            //int j = 1;//临时变量，只在这个代码块中有效
//            auto int j = 1;//等价
//            printf("before:%d\n", j);
//            j++;
//            printf("after:%d\n", j);
//        }
//    }
//    return 0;
//}

//结论：已经很老了，基本不使用



//2、最快的关键字 - register  寄存器关键字
  
  //建议性关键字，计算机可以是不听的

//其实CPU主要负责进行计算的硬件单元，但是为了方便运算，一般第一步需要先把数据从内存读取
   //到CPU内，那么也就需要CPU具有一定的数据临时存储能力。注意：CPU并不是当前要计算了，才
    //把特定数据读到CPU里面，那样太慢了
//所以现代CPU内，都集成了一组叫做寄存器的硬件，用来做临时数据的保存


//寄存器
//cache   //使用的SRAM芯片
//内存
//SSD/flash/硬盘
//DDH
//光盘
//磁带

//寄存器、cache都在CPU中，离CPU越近的存储单元，效率越高，单价成本越贵
                        //离CPU越远的存储单元，效率越高，单价成本越便宜
//任何一种硬件而言，充当上游硬件的缓存   
//CPU访问数据的时候，以最小的成本，达到最高的效率

//寄存器存在的本质：
  //在硬件层面上，提高计算机的运算效率。因为不需要从内存里读取数据啦

//register修饰变量
  //尽量将所修饰变量，放入CPU寄存器中，从而达到提高效率的目的
//那么什么样的变量，可以采用register呢？
  //1、局部的（全局会导致CPU寄存器被长时间占用）
  //2、不会被写入的（写入就需要写回内存，后续还要读取检测的话，register的意义在哪呢？）
  //3、高频被读取的（提高效率所在）
  //4、如果要使用，请不要大量使用，因为寄存器数量有限
 //注：这里除了上面的。再有一点，就是register修饰的变量，不能取地址（因为已经放在寄存器中了， 
    //地址是内存相关的概念）

//int main()
//{
//    register int pass = 100;
//    pass = 200;//这是可以被写入的
//    printf("%d\n", pass);
//    return 0;
//}

//建议是：该关键字，不用管，因为现在的编译器已经很智能了，能够进行比人更好的代码优化
        //早期编译器需要人为指定register，来进行手动优化，现在不需要了



//关键字 - 第二讲
//课程目标
  //在多文件中，关于全局变量和函数的一些结论
  //如何看待类型
  //变量的命令规则
  //sizeof的理解

//3、最名不符实的关键字 - static
  //建立VS中的多文件项,


//#include <windows.h>
//#include "test.h"
//extern int g_val;//这样写是可以的
////extern int g_val = 100;//这样写是不可以的
////这是因为申明并没有开辟空间!    赋值=100，叫做赋值或初始化
////所有的变量声明的时候，不能设置初始值！
//int main()
//{
//    printf("%d\n", g_val);
//    show(200);
//    system("pause");
//    return 0;
//}//这样是强制打印是可以打印的，但是会有很多的警告


//为什么要有头文件？

//单纯的使用源文件，组织项目结构的时候，项目越打越复杂的时候，维护成本会变得越来越高！
//就这样，所有项目都要用，于是诞生了头文件。
  //.h：头文件，组织项目结构的时候，减少大型项目的维护成本问题



//.c文件永远放的都是所有的定义，除了main.c因为这个是主程序
//.h文件永远放的都是所有的声明



//头文件一定会被多个源文件包含，可能有一个问题：头文件重复包含的问题
  //解决方案：方法一：头文件最开始写  #pragma once

//#include "test.h"//包含文件头文件用双引号


//问题：
//1、全局变量可以跨文件访问吗？    //可以
//2、函数可以跨文件访问吗？        //可以

//为什么？
//有一定规模的项目，一定是多文件的，多个文件之间，后续一定要进行数据“交互”
//（#include "test.h",main.c->test.c函数），如果不能跨文件，“交互”成本比较高

//总有一些需要被隐藏的部分，所以出现了static

//在具体的应用场景当中，有没有可能，我们不想让全局变量或者函数跨文件访问，
  //指向在本文件内部被访问


//static结论：
  //1、static修饰全局变量代表的是该变量只在本文件内被访问，不能被外部其他文件直接被访问
                                                                     //可以间接被访问嘛

//#include "test.h"
//int main()
//{
//    show(200);
//    system("pause");
//    return 0;
//}
//2、static修饰函数，该函数只能在本文件内被访问，不能在外部其他文件直接访问

//#include "test.h"
//int main()
//{
//
//    show(200);
//    system("pause");
//    return 0;
//}

//static 是项目维护，提供安全保证，因为自己写的工程让被人拿去用的时候，不能将全局变量暴
// 露出来一旦暴露出来，拿走的人就会进行该程序，所以要用static来修饰，这样就不会将重要参
// 数暴露给别人


////i是局部变量，局部临时性，函数调用开辟空间并初始化
////函数结束释放空间并初始化
//static void fun()//加个static表明的是只能被本文件进行识别，别的文件识别不出来
//{
//    int i = 0;//申请空间，初始化为0
//    i++;
//    printf("i = %d ,[%p]\n", i, &i);//这里的地址是不变的
//}//完了之后，i直接释放,i在不断被释放
//int main()
//{
//    for (int i = 0; i < 10; i++)
//    {
//        fun();
//    }
//    system("pause");
//    return 0;
//}
////10个1是因为i局部变量，具有临时性


//3、static修饰局部变量 - 更改局部变量的作用域还是生命周期呢？
                        //改变的是生命周期
                        //作用域还是只在本代码块内有效


//static void fun()
//{
//    static int i = 0;
//    i++;
//    printf("i = %d ,[%p]\n", i, &i);
//}//这里i就称为了1 2 3 4 5 6 7 8 9 10 
//int main()
//{
//    for (int i = 0; i < 10; i++)
//    {
//        fun();
//    }
//    system("pause");
//    return 0;
//}

//i在fun运行的过程中，并没有被释放！！！

////证明一下：
//int* p = NULL;
//static void fun()
//{
//    static int a = 100;
//    p = &a;//取地址a
//}
//int main()
//{
//    fun();//如果a是局部变量的话，一定会被释放
//    printf("%d\n", *p);
//    system("pause");
//    return 0;
//}

//上面这里就会出现一个问题：
  //为什么临时变量具有临时性，全局的局部变量具有全局性

//C程序地址空间
    //"进程"：程序被加载到内存中
//C语言程序地址空间是内存吗？  它不是内存

//C语言程序地址空间在任何一本C语言书中，都找不到这词！

//因为这不是C语言的概念，这是操作系统的，是进程地址空间



//4、基本数据类型
  //C语言数据类型
    //基本类型
        //数值类型
        //字符类型char
            //整型
                //短整型（short）
                //整型（int）
                //长整型（long） 
            //浮点型
                //单精度型（float）
                //双精度型（double）
    //构造类型
        //数组
        //结构体struct
        //共用体union
        //枚举类型enum
    //指针类型
    //空类型void  



//C语言常见内置类型
   //char short int long long float double 
//定义变量的本质：在内存中开辟一块空间，用来保存数据
//而定义一个变量，是需要类型的，这个是由基本语法决定的，那么，类型决定了：变量开辟空间的大小

//sizeof//单位是字节
//sizeof：确定一种类型对应在开辟空间的时候的大小问题

//int main()
//{
//    printf("%d\n", sizeof(char));//1
//    printf("%d\n", sizeof(short));//2
//    printf("%d\n", sizeof(int));//4
//    printf("%d\n", sizeof(long));//4
//    printf("%d\n", sizeof(long long));//8
//    printf("%d\n", sizeof(float));//4
//    printf("%d\n", sizeof(double));//8
//    system("pause");
//    return 0;
//}

//sizeof  是一个关键字（操作符），求特定类型对应开辟空间的大小

//sizeof是函数吗？
//它不是函数，他是关键字（操作符）
//在汇编语言中。sizeof不会压栈，这就说明sizoeof不是函数，函数调用是会压栈的

//为什么根据类型，开辟一块空间，直接将内存整体使用不好吗？
//不好
//任何时候，都不是你一个程序在运行，还有其他程序也在运行。你整块用了，让别人怎么办？
  //另外，你全都用了，一定需要在任何时候，全部都用完吗？对于暂时不用，但是给你了，对计算
  //机来讲，这就是浪费

  //所以C语言中，为什么会有那么多的类型？就是为了满足不同的计算场景。
    //不同的应用场景所对应的计算方式是不同的，需要空间的大小也是不同的
//本质：用最小成本，解决各种多样化的场景问题



//变量命名规则：
  //1）一般规则：见名知意
  //2）标识符的长度一般不要过长，较长的单词可以通过去掉“元音”形成缩写
       //英文词尽量不缩写，特别是非常专业的名词；如果有缩写，在同一系统中对同一单词必须
       //使用相同的表示法，并且著名其意思
  //3）当标识符由多个词组成时，每个单词的第1个字母大写，其余全部小写（大驼峰命名）
  //4）尽量避免名字中出现数字编号，除非逻辑上的却需要编号
  //5）对在多文件之间共同使用的全局变量或函数要加范围限定符（建议使用模块名（缩写）作为
       //范围限定符）
  //6）程序中不得出现仅靠大小区分的相似的标识符
//int x, X;
//int o, O;//这种严重不推荐
  //7）函数名和变量名强烈建议不要相同
  //8）定义宏的话，建议全部大写而且单词与单词之间用下划线来连接
  //9）初学阶段用a,b,c来用做变量名可以接受，在业务上就不能这样来使用了
  //10）定义变量的时候，千万别忘了初始化，如果不进行初始化，编译器一般情况就会
       //默认生成随机数

//局部变量不做初始化，内容是随机值
  //11）不同类型数据之间的运算要注意精度扩展问题，一般低精度数据将向高精度数据扩展（精度提升）
  //命名的构成：数字字母下划线


//5、最冤枉的关键字 - sizeof理解

  //sizeof(int)* p表示什么意思
//int main()
//{
//    int* p = NULL;
//    int arr[10];
//    int* test[3];
//    printf("%d\n", sizeof(p));//4
//    printf("%d\n", sizeof(arr));//40    4*10
//    printf("%d\n", sizeof(test));//12   4*3
//    return 0;
//}


  //关键字 - 第三讲
//本章重点：
  //掌握原反补概念
  //十进制到二进制、二进制到十进制的转换口诀
  //深刻理解数据的取值范围
  //解决三份代码

//6、signed、unsigned
  

  //原反补
//之前讲过一个变量的创建是要在内存中开辟空间的，空间的大小是根据不同类型而决定的
  //那么，数据在所开辟内存中到底是如何存储的呢？
//int main()
//{
//    //有符号数：
//
//    //int a = 10;
//    
//    //原码、反码、补码
//    //不管是原反补中的任何一个，在计算机中，都必须被转化成二进制，因为计算机只认识二进制
//    //符号位 + 数据位
//    //有符号数：
//    //且是正数：原码 = 反码 = 补码
//    //0000 0000 0000 0000 0000 0000 0000 1010   -   10的原码
//       //0x00 00 00 0A                      -  16进制
//    
//       //int b = -20;
//    
//    //是负数：原码、反码、补码是不相同的
//    //1000 0000 0000 0000 0000 0000 0001 0100 - -20的原码
//    //1111 1111 1111 1111 1111 1111 1110 1011 - 反码（原码的符号位不变，其他位按位取反）
//    //1111 1111 1111 1111 1111 1111 1110 1100 - 补码（反码 + 1）
//       //0xFF FF FF EC                      -  16进制
//    //注意：当反码+1得到补码的时候，符号位参不参与运算？
//       //只要是加法，符号位是要参与运算的
//
//
//    //补码转成原码：
//
//    //方法一：
//      //补码-1，再按位取反得到原码
//    //方法二：
//      //将补码的符号位不变，其他位按位取反，之后再 + 1
//
//    //用方法一来理解，用方法二进行运算，方法二才是有价值的
//      //这些转化都是通过计算机硬件进行完成的，原码<=>反码<=>补码
//         //这样就可以只用一条硬件电路，就可以完成转化
//     
//    //无符号数：
//      //没有符号位：原码 = 反码 = 补码
//      //直接存
//
//
//    //符号数：来看看存储的本质
//    //unsigned int a = 10;
//    unsigned int b = -10;//这是对的
//    //定义变量并且做了初始化，先有空间，再有内容
//    //整型存储的时候，空间是不关心内容的
//    //在将数据保存在空间内的时候，数据已经被转化称为二进制了
//
//    //那么这里的变量类型unsigned int什么时候起效果
//    
//    //在读取的时候，具有意义！类型决定了如何解释空间内部保存的二进制序列
//
//    //（单纯的10是没有意义的，数字需要带上类型才有意义！）
//
//    printf("%u\n", b);//unsigned int //4294967286//对两个的理解是不同的（有符号整型来理解的）
//    printf("%d\n", b);//-10(无符号整型来理解的)
//
//    //变量存的过程：字面数据先转换成补码，再放入空间当中。所以，所谓符号位，完全看数据本身
//                  //是否携带+-号，和变量是否有符号无关
//    //变量取的过程：取数据一定要先看对应变量本身类型，然后才决定要不要看最高符号位，如果
//                  //不需要，直接二进制转换成十进制。如果需要，则需要转成原码，然后才能识
//                  //别。（当然，最高符号位在哪里，又要明确大小端）
//
//         //1、先看自身类型决定
//            //a、先看符号位
//            //b、确定原反补
//    return 0;
//}


//二进制快速转化口诀：
  //67转成二进制：
  //67 -> 64  +  2  + 1 
  //      2^6  2^1  2^0
  
 //核心口诀：2的几次方，就是1后面跟几个0



//int main()
//{
//    unsigned int a = -10;
//    //要先将-10转换成补码，然后再存到空间之中
//    return 0;
//}


//  //大小端：
//int main()
//{
//    int a = 0xAABBCCDD;
//    //内存地址是依次增大的，为何呢？地址为何是反着存的？？
//    return 0;
//}

//如何理解大小端？

//每个字节都有地址！所有的地址都是不同的，那么肯定是有大小的！
//所以在内存中，内存存储就从上到下依次为从高地址到低地址，地址有高地址和低地址之分
  //（是按照字节为单位来区分的）
  // 所以数据也要按照字节为单位划分成若干块
//0x  12  34 56  78
 // 权值    >   权值
//因为权值的原因，数据按照字节为单位，也是有高权值位，低权值位之别的

//如何放？
  //无论如何放，只要同等去取，都可以！（这个由计算机，内存硬件厂商决定）
//由于原来的厂商都是独立的，并且相互都有竞争关系的，所以这两种存储模式都出来了

//产生的两种存储模式：
//1、大端方案：
  //数据按照字节为单位，低权值位数据存储在高地址处，就叫做大端

//2、小端方案：
  //数据按照字节为单位，低权值位数据存储在低地址处，就叫做小端

//例如：int a = 0x11223344

//  0xA0  A1  A2  A3(低地址--->高地址)
  //  11  22  33  44   //这就是大端
  //  44  33  22  11   //这就是小端

//口诀：小端：小小小（低权值位：权值位比较小，低地址处：地址数字比较小，小端：小）

//大小端基本的概念?（就是上面的）


//大小端是如何影响数据存储的？
  //大小端存储方案，本质上是数据和空间按照字节为单位的一种映射关系

//内存地址以相同的规则来存进去，以相同的规则来取出来，这东西都是计算机自动完成，
//对用户没有任何影响的，不影响用户的使用


//unsigned int a = -10;

//这个数据是如何存的
//1、有对应的空间（int类型）
//2、将-10转换成二进制补码
  //1111 1111 1111 1111 1111 1111 1111 0110
//3、按照大小端开始存储数据（也就是按照低地址和高地址处进行的）


//那么该如何存储呢？
//1、先看自身类型
//2、再根据大小端的定义进行取出



//小端，有符号数
//1、先看大小端

//2、再看自身类型：有符号，就先看符号位，那就要判断是补码还是其他的，
     //就要进行原反补转换




//整形取值范围：
    //简单起见，以char为例
    //unsigned char:[0,2^8-1]
  //signed char:[-2^7,2^7-1]
    //特定数组类型，能表示的数据取值范围（范围由多个连续数据构成），
                             //本质是多位比特位形成的排列组合的个数

//signed(有符号)     char为例：
  //0 000  0000
//其中最高比特位是符号位
//意味着只有7个数值为？？
//原码：
//1 111 1111  -> -127

//0 111 1111  -> +127

//[-128~~127],有什么问题？？

//
//int main()
//{
//    char a = -128;//八个比特位
//    //1 1000 0000      -    -128的原码
//    //1 0111 1111      -          反码
//    //1 1000 0000      -          补码
//    
//    //开始存到内存中
//    //内存只有八个比特位，但是这里有九个，怎么办
//
//    //这时出现截断，只存放的是1000 0000   -   这里是128
//    //上面是存的问题
//
//    //那如何取呢？？
//    //当再由补码转换成原码的时候就不对了，因为少个比特位，这样出来的值是不对的
//
//    //半计算半规定的一种方式！
//    //规定一下 1000 0000 -> 这种是-128，为什么能这样子规定，在规定的时候，正好这个数没用，所以就用这个来做个规定
//    //所以出现了-128的事，这是非常巧合，设计原反补的人专门这样设计的，特定规定的
//    printf("%d\n", a);
//    return 0;
//}


//char   [-128，127]      [-2^7，2^7-1]
//short  [-2^15，2^15-1] 
//int    [-2^31，2^31-1]
//这是合法范围！


//为什么都是补码？
//在计算机系统中，数值一律用补码来表示和存储。原因在于。使用补码，可以将符号位和数值域统一
//处理；同时，加法和减法也可以统一处理（CPU只有加法器）。此外，补码与原码相互转换，其运算
//过程是相同的，不需要额外的硬件电路

//在计算中全部被转化成加法，依靠的是补码
//为啥都要转化成加法（因为计算都在CPU中，CPU中是有硬件计算电路，这样的话只要设计一套就够了）

//例题：
////code1：（char类型数值范围的那个圈）
//#include <windows.h>
//int main()
//{
//    char a[1000];
//    int i;
//    for (i = 0; i < 1000; i++)
//    {
//        a[i] = -1 - i;
//    }
//    printf("%d\n", strlen(a));//"\0"的重要性
//    return 0;
//}

//i=0 :  -1
//i=1 :  -2
//i=2 :  -3
//....
//i=127 : -128

//1111 1111    -127的原码
//1000 0000    -127的反码
//1000 0001    -127的补码


//1000 0001    -1的原码
//1111 1110    -1的反码
//1111 1111    -1的补码

//补码相加
//1111 1111
//1000 0001   +
//―――――――
//1 1000 0000

//又出现九个比特位，发生截断
//1000 0000    //存进去的是这个  这个就是规定 -128  (这里就用到了半计算半规定的)


//当i=128时  ：  127


//1111 1111
//1000 0000   +
//―――――――
//1 0111 1111  
//存到内存中的时候发生截断，存的是0111 1111  --  这是127
//（-1）+（-128）:本身已经越界了（超过数据范围），变成正数是正常的（因为这里当成一个圈，来看待）

//当i=129时 ：126
//1111 1111
//0111 1111  +  （129的补码）
//――――――-
// 1 0111 1110

//开始存储是0111 1110   =  126

//当i=130时 ：125

//所以这样不断地减一定可以减到0
//所以这里a[255]的时候，这里是0


////code2
//#include <windows.h>
//int main()
//{
//    int i = -20;
//    unsigned int j = 10;
//    printf("%d\n", i + j);
//    printf("%u\n", i + j);//4294967286  这就是下面加起来的补码
//    system("pause");
//    return 0;
//}
//-20
//1000 0000 0000 0000 0000 0000 0001 0100  --  原码
//1111 1111 1111 1111 1111 1111 1110 1011  --  反码
//1111 1111 1111 1111 1111 1111 1110 1100  --  补码

//10  正数，原反补相同
//0000 0000 0000 0000 0000 0000 0000 1010  --  补码

//1111 1111 1111 1111 1111 1111 1110 1100 
//0000 0000 0000 0000 0000 0000 0000 1010
//1111 1111 1111 1111 1111 1111 1111 0110  --  加起来的补码
//1000 0000 0000 0000 0000 0000 0000 1001  --  加起来的反码
//1000 0000 0000 0000 0000 0000 0000 1010  --  加起来的原码
//所以这个答案就是-10


////code3
//#include <windows.h>
//int main()
//{
//    unsigned int i;
//    //死循环
//    //for (i = 9; i >= 0; i--)
//    //{
//    //    printf("%u\n", i);//9 8 7 6 5 4 3 2 1 0   4294967295   4294967294  ......
//    //    //4294967295  这个数字是32位的全1，然后依次往下减
//    //    Sleep(1000);//休眠一秒钟
//    //}、
//    for (i = 0; i >= 0; i++)
//    {
//        printf("%u\n", i);
//        Sleep(1000);
//    }//这个就是从0可以开始往上进行加，加到32位的全1
//    return 0;
//}


//int main()
//{
//    int a = 10;
//    unsigned int b = 10;
//    unsigned int b = 10u;//加个u 两边的类型就严格一致了
//    return 0;
//}



  //关键字  --  第四讲
//本章重点
  //什么是语句，表达式
  //bool变量 和 0 比较
  //float变量 和 0 比较
  //指针变量 和 0 比较
  //else匹配问题以及 if 的其他常见问题

//7、if else组合
  //语句：
    //C语言中由一个分号;隔开的就是一条语句
  
  //什么是表达式：
    //C语言中，用各种操作符把变量连起来，形成有意义的式子，就叫做表达式。
//int main()
//{
//
//        int flag = 2;
//        if (1 == flag)
//        {
//            printf("hello world\n");
//        }
//        else if (2 == flag)
//        {
//            if (1)
//            {
//                printf("............\n");
//            }
//            printf("hello C");
//        }
//        else
//        {
//            printf("hello \n");
//        }
//
//    
//    return 0;
//}//分支嵌套


////有一种很巧妙的注释方案if(0)
//int main()
//{
//    if (0) {//但是不推荐这种注释
//        int flag = 2;
//        if (1 == flag)
//        {
//            printf("hello world\n");
//        }
//        else if (2 == flag)
//        {
//            if (1)
//            {
//                printf("............\n");
//            }
//            printf("hello C");
//        }
//        else
//        {
//            printf("hello \n");
//        }
//    }
//    
//    return 0;
//}



//C语言中，0为假，非零为真，从上面的代码可以看出来的

//int main()
//{
//    int flag = 1;
//    if (flag == 1)
//    {
//        printf("hello world\n");
//    }
//    return 0;
//}//这里的执行细则是什么？
////1、先执行对应的()中的表达式，得到真假结果
////   判断的是flag的真假结果
////2、根据条件判定的结果进行分支功能if()
////   if判断的是最后的真假结果

//int IsEmpty()
//{
//    printf("某种数据是否为空！\n");
//    return 1;
//}
//int main()
//{
//    //int ret = IsEmpty();
//    if (IsEmpty())
//    {
//        printf("yes\n");
//    }
//    return 0;
//}


//布尔变量与0的比较


//深入理解C中的bool
  //C语言有没有bool，C99之前，主要是是C90是没有的，目前大部分书中，都认为是没有的。因为书
    //要落后于行业
  //但是C99引入了bool类型，在新增的头文件stdbool.h中，被重新用宏写成了bool，为了保证C/C++
    //兼容性
//现在还是用C90的标准比较多
//int main()
//{
//    bool x = ture;
//    return 0;
//}

//#include <stdbool.h>
//int main()
//{
//    bool x = true;
//    x = false;
//    printf("%d\n", sizeof(x));
//    return 0;
//}

//ps:理论上，表示真假，需要一个bit就够了，不过这个问题，还是要取决于编译器的理解


//int main()
//{
//    BOOL x = TRUE;//微软的标准，是整型，但是不推荐这个标准
//    //typedef int BOOL;
//    x = FALSE;
//    printf("%d\n", sizeof(x));
//    return 0;
//}


//#include <stdbool.h> 
//int main()
//{
//    int flag = 0;
//    if (flag == 0)//（可能会误认为整数比较）int x == 0//这两种是看不出来的，
//                    // 从语义中透露出来的不直观
//    {
//        //不推荐
//        printf("1\n");
//    }
//    if (flag == false)//1、C99,不要头文件可能就会编译不过
//    {
//        //不推荐
//        printf("2\n");
//    }
//    if (!flag)//这样写，就直观的反映出    flag是"bool"型
//    {
//        //推荐这种，
//        //为什么呢？？
//        //1、先执行（）中的表达式or函数，得到真假结果（就是我们的true false
//                                                  //  这种结果叫做逻辑结果）
//        //2、条件  判定功能
//        //3、进行  分支功能
//        printf("3\n");
//    }
//    return 0;
//}

//#include <stdbool.h>
//int main()
//{
//    bool x = true;
//    if (x)//这种是比较推荐的
//    {
//
//    }
//    return 0;
//}
//结论：bool类型，直接判定，不用操作符进行和特定值比较


//float变量和0进行比较

//double和float差不多，只要出现小数点的，编译器就默认成double类型的

//浮点数在内存中存储，并不是我们想的完整存储，在十进制转换成二进制，是可能有精度损失的。
//注意这里的损失，不是一味的减少了，还有可能增多，浮点数本身存储的时候，在计算不尽的时候
//会"四舍五入"

//int main()
//{
//    ////float d = 3.6;//(3.6是double类型的)
//    ////消除警告的话就这样：
//    //float d = 3.6f;
//
//    double d = 3.6;
//    printf("%.50f\n", 3.6);//3.60000000000000008881784197001252323389053344726562
//                           //后面这个就是精度损失
//    double x = 1.0;
//    double y = 0.1;
//    printf("%.50f\n", x - 0.9);//应该是0.1
//                               //0.09999999999999997779553950749686919152736663818359
//    printf("%.50f\n", y);//应该是0.1
//                         //0.10000000000000000555111512312578270211815834045410
//    //这里还是造成精度损失，所以导致这两个打印出来的不同
//    return 0;
//}

////有了精度损失之后
//int main()
//{
//    double x = 1.0;
//    double y = 0.1;
//    if ((x - 0.9) == 0.1)
//    {
//        printf("you can see me!\n");
//    }
//    else
//    {
//        printf("oops!\n");
//    }//打印的是oops!
//    return 0;
//}
//打印浮点数在进行比较的时候，绝对不能直接使用==来进行比较！！！！
//浮点数本身有精度损失，进而导致各种结果可能有细微的差别！！！

//所以，浮点数也不能和  零值  进行比较

//#define EPSILON 0.0000001     //假设自己定义了一个精度
//不能直接写   x - y == 0
             //这是伪代码 
//    而要写   x - y > -EPSILON && x - y < EPSILON   //进行比较，要满足这个条件的

//精度：
  //自己设置？后面如果有需要，可以试试，通常是宏定义。
  //使用系统精度？暂时推荐


//#include <math.h>
//#define EPS 0.000000000001//自定义方案
//int main()
//{
//    double x = 1.0;
//    double y = 0.1;
//    if (fabs((x - 0.9) - y) < EPS)//fabs是绝对值的意思，所以头文件得用math.h
//    {
//        printf("can you see me!!!\n");
//    }
//    else
//    {
//        printf("oops!!!\n");
//    }
//    //这里打印出来的就是：can you see me!!!
//    return 0;
//}

//可以使用系统所提供的

//#include <float.h>//使用下面两个精度，需要包含该头文件
//DBL_EPSILON//double 最小精度
//FLT_EPSILON//float  最小精度

//#include <float.h>
//#include <math.h>
//int main()
//{
//    double x = 1.0;
//    double y = 0.1;
//    if (fabs((x - 0.9) - y) < DBL_EPSILON)
//    {
//        printf("can you see me!!!\n");
//    }
//    else
//    {
//        printf("oops!!!\n");
//    }
//    //这里打印出来的就是：can you see me!!!
//    return 0;
//}

//#include <math.h>
//#include <float.h>
//int main()
//{
//    double x = 0.0;
//    if (x == 0.0)
//    {
//
//    }
//    
//    //if (fabs(x - y) < DBL_EPSILON)//用这个就可以了，不需要再用上面的那个来进行比较
//                                  //这样子比较更准确
//        //若y=0,就是
//    if(fabs(x)< DBL_EPSILON)
//    {                         
//
//    }
//    return 0;
//}

//#include <float.h>
//int main()
//{
//    double x = 0.00000000000000000000001;
//    if (x > -DBL_EPSILON && x < DBL_EPSILON)
//    {
//        printf("you can see me!! x == 0.0\n");
//    }
//    else
//    {
//        printf("oops!\n");
//    }
//    return 0;
//}

////现在呢？
//#include <float.h>
//int main()
//{
//    double x = 0.00000000000000000000001;
//    //要不要相等
//    if (x >= -DBL_EPSILON && x <= DBL_EPSILON)
//    {
//        printf("you can see me!! x == 0.0\n");
//    }
//    else
//    {
//        printf("oops!\n");
//    }
//    return 0;
//}

//个人看法：XXX_EPSILON是最小误差,是：XXX_EPSILON+n不等于n的最小的正数。
// XXX_EPSILON + n不等于n的最小的正数: 有很多数字 + n都可以不等于n，但是XXX_EPSILON
// 是最小的，but，XXX_EPSILON依旧是引起不等的一员。
//换句话说：fabs(x) <= DBL_EPSILON(确认x是否是0的逻辑)，如果=，就说明x本身，已经能够
// 引起其他和他+-的数据本身的变化了，这个不符合0的概念。


//浮点数和0比较
//1、浮点数存储的时候，是有精度损失的（实验验证了）
//2、浮点数是不能进行 == 比较的
//3、if(fabs(a-b))<DBL_EPSTILON){}
//4、要不要<=,>=,细节




//int main()
//{
//    printf("%d\n", 0);
//    printf("%d\n", '\0');
//    printf("%d\n", NULL);
//    //这三个打印出来的值是相同的，但是这是类型是不同的
//
//    return 0;
//}
//
////如何理解强制类型转换
//
////真实的转化  ：改变内存中的数据
////强制类型转化：不改变内存中的数据，只改变对应的类型
//int x = (int)3.14;
////还是先有空间，再放内存，只是将类型对应的改变了


//指针变量与“零值”进行比较

//指针变量与“零值”进行比较的if语句怎么写？
//int main()
//{
//    int* p = NULL;//定义指针一定要同时初始化
//    //1、 if (p == 0);     //不推荐这样写
//      //  if (p != 0);//写的是没问题的，但是两边类型是不相同的
//    
//      //2、if(p);        //也不推荐这样写
//       //  if(!p);  //逻辑上与上面的额代码是相反的
//    
//       //3、if(NULL == p);   //推荐这样子写   
//         // if(NULL != p);   //为啥NULL == p  因为在一些新手写的时候，容易写成两个等号写成
//                             //一个错误，p = NULL 的话编译器不直接报错的，而反过来直接
//                             //会报错
//    return 0;
//}




//else到底与哪个if匹配 ？
  
//int main()
//{
//    //int x = 0;
//    int x = 10;
//    int y = 1;
//    if (10 == x)
//        if (11 == y)
//            printf("hello world!!\n");
//        else
//            printf("hello 世界!\n");
//    return 0;
//}//为何他不编译出来内容呢？
////这是因为else是离他最近的未匹配的if相匹配
////else匹配采用就近原则


//int main()
//{
//    int x = 0;
//    int y = 1;
//    if (10 == x)
//    {
//        if (11 == y)
//        {
//            printf("hello world!\n");
//        }
//    }
//    else
//    {
//        printf("hello 世界！\n");
//    }
//    return 0;
//}//这里else匹配的是第一个if


//int main()
//{
//    int flag = 1;
//    if (flag);
//    {
//        printf("hello world!\n");
//    }
//    //这里就是
//    if (flag)
//        ;//就是这个样子的，分号是空语句的
//    return 0;
//}



//if ((x = y) != 0)//boolean
//   //这里的顺序是先将y的值赋给x，在将x与零开始做比较得到一个bool的值，由if判断，为真为假，
//      再执行下面的语句运算
//{
//    foo();
//}

//这样子写法不推荐，推荐下面的写法：


//x = y;
//if (x != 0)
//{
//    foo();
//}



//8、 switch case  组合

//多条件匹配，switch(整型变量/常量/整形表达式)

//int main()
//{
//    //if:判断 分支
//    int day = 0;
//    scanf("%d", &day);
//   
//    //判断 分支
//    switch (day)
//    {
//    case 1://执行判断能力
//        printf("星期一\n");
//        break;//完成的是相当于if语句中的分支功能
//    case 2:
//        printf("星期二\n");
//        break;
//    case 3:
//        printf("星期三\n");
//        break;
//    case 4:
//        printf("星期四\n");
//        break;
//    case 5:
//        printf("星期五\n");
//        break;
//    case 6:
//        printf("星期六\n");
//        break;
//    case 7:
//        printf("星期天\n");
//        break;
//    }
//    return 0;
//}



//任何具有判定能力的语法结构，都必须具备：判定+分支

//每个case语句的结尾绝对不要忘了加break，否则将导致多个分支重叠（除非有意使多个分支重叠）

//最后必须使用default分支，即使程序真的不需要default处理，也应该保留以下语句：
                                    //default:
                                    //    break;
//int main()
//{
//    int day;
//    while (1)
//    {
//        printf("Please Enter Your Day:");
//        scanf("%d", &day);
//        switch (day)
//        {
//        case 1:
//            int a = 10;//这里的错误没关系，还是可以编译过去的，当前限于这个编译器
//            printf("星期一\n");
//            printf("星期一\n");
//            printf("星期一\n");
//            printf("星期一\n");
//            printf("%d\n", a);//按道理是无法运行的。但结果是VS2019是可以运行的
//                              //非要进行这样的话，就给case 1后面带上带上大括号
//            break;
//        case 2:
//            printf("星期二\n");
//            break;
//        case 3:
//            printf("星期三\n");
//            break;
//        case 4:
//            printf("星期四\n");
//            break;
//        case 5:
//            printf("星期五\n");
//            break;
//        case 6:
//            printf("星期六\n");
//            break;
//        case 7:
//            printf("星期天\n");
//            break;
//        default:
//            printf("Please input error,Please re-enter: ");
//        }
//    }
//    return 0;
//}


//default 一般情况都放在后面的，可以放在代码中的任意位置
    //建议放在最后，必须得有


//int main()
//{
//    int day = 0;
//    int quit = 0;//相当于定了一个bool值
//    while (!quit)//必须要进行逻辑反
//    {
//        printf("Please Enter Your Day:");
//        scanf("%d", &day);
//        switch (day)
//        {
//        case 1:
//            printf("星期一\n");
//            break;
//        case 2:
//            printf("星期二\n");
//            break;
//        case 3:
//            printf("星期三\n");
//            break;
//        case 4:
//            printf("星期四\n");
//            break;
//        case 5:
//            printf("星期五\n");
//            break;
//        case 6:
//            printf("星期六\n");
//            quit = 1;//这里表示退出，在这里退出
//                     //用一些编程技巧来替换掉了break退出的部分
//            break;
//        case 7:
//            printf("星期天\n");
//            break;
//        default:
//            printf("Please input error,Please re-enter: ");
//        }
//    }
//    return 0;
//}


//case之后，如果没有break,则会依次执行后续有效语句，直到碰到break

//如果定义的是const常变量

//int main()
//{
//    const int a = 4;
//    switch (a)
//    {
//    case 4:
//        //case a:这样子就不对，case 后面跟的是常量，不要用那些假常量来跟在后面
//        printf("hello world!\n");
//        break;
//    default:
//        break;
//    }
//    return 0;
//}

//case语句尽量按字母或数字顺序排列各条case语句

//按执行频率来排列case语句

//这样子就可以

//#define A 10
//int main()
//{
//    int a = 10;
//    switch (a)
//    {
//    case A:
//        printf("hello world!\n");
//        break;
//    default:
//        break;
//    }
//    return 0;
//}

//用define 来定义变量



//switch && case && break && default 

//1、switch 语句结构中，case完成的判定功能，break完成的是分支功能，default处理异常情况
//2、case: 执行语句 == 1：n，case多条语句（不能定义变量，如果需要：{} 或 函数）break
//                    //一条语句匹配多个
//3、case: 执行语句 == n：1，多条case后续不写break
//                    //多条语句匹配一个
//4、default: 可以出现在任何地方，推荐放在结尾
//5、case: 不能：const，普通的变量，建议要有好的布局case的方式





//关键字 -- 第六讲

//本章重点
  //循环的语法理解
  //break和continue的作用
//goto真的没人用吗？
//void的理解
//void 修饰函数和函数参数的作用
//void指针的用途


//9、do、while、for 关键字


//三种条件的语法结构：


//int main()
//{
//    int count = 10;//循环条件初始化
//    while (count > 0)//循环条件判定
//    {
//        //业务逻辑的代码
//        printf("%d\n", count);
//        count--;//循环条件更新
//    }//与if的区别就是这个可以一直循环到上面，再次实现业务逻辑的代码
//    return 0;
//}

//要有三个基本条件：循环条件初始化，循环条件判定，循环条件更新


//int main()
//{
//    for (int i = 0; i < 10; i++)//这三部分是在这里的
//        //这有一个最大的好处就是：可以直接一眼看到这三个循环条件
//        //这就是for循环用的最多的原因
//    {
//        printf("%d\n", i);
//    }
//    return 0;
//}


//int main()
//{
//    int count = 10;//循环条件初始化
//    do
//    {
//        printf("%d\n", count);
//        count--;//循环条件更新
//    } while (count > 0);//要以分号结尾  //循环条件判定
//       //至少执行一次就用 while(0)
//    return 0;
//}//先尝试执行一次之后，再进行条件更新





//三种写法的死循环写法：


//int main()
//{
//    //do
//    //{
//    //    printf(".");
//    //} while (1);
//
//    //for (;;)
//    //{
//    //    printf(".");
//    //}
//
//
//
//    //while (1)//逻辑真
//    //{
//    //    printf(".");
//    //}
//    return 0;
//}



//任何程序，在默认编译好了之后，运行时，都会打开三个输入输出流

//stdin : 标准输入   FILE* stdin   键盘
//stdout: 标准输出   FILE* stdout  显示器
//stderr: 标准错误   FILE* stderr  显示器   

//这部分，首先得了解这些计算机组成，体系结构，操作系统


//C语言并没有打开过文件，为什么scanf这个函数，可以通过键盘来输入内容

//这是在C程序在启动时，系统会默认将这三个全部打开，scanf本质就是从键盘上写入数据
//系统管理会默认打开这三个输入输出流


////stderr:  perror函数
//int main()
//{
//    perror("hello world!\n");
//    return 0;
//}

//int main()
//{
//    while (1)
//    {
//        int c = getchar();
//        //输入a的时候，就会按键回车，回车也是一个换行符，所以就会出现两行空的
//        if (c == '#')
//        {
//            break;
//        }
//        //printf("%c\n", c);
//        //就可以改上面这一行,变成每次输入输入之间都没有空行
//        printf("%c", c);
//    }
//    printf("while end ...\n");
//    return 0;
//}

//char getchar 
//[0,255]
//getchar:成功还好
//getchar:返回失败，0000 0000 1111 1111 -> 1 0000 0000

//int main()
//{
//    float a = 0;
//    scanf("%f", &a);//注意：输进去的数字全部都是字符，3.14就是3字符，.字符，1字符，4字符
//    printf("%f\n", a);
//    return 0;
//}

//注意：键盘上输入的内容，或者往显示器中打印的内容，全部都是“字符”！！！！！！
       //1234 就是字符1，字符2，字符3，字符4

//#include <Windows.h>
//int main()
//{
//    while (1)
//    {
//        char c = getchar();
//        //if (c = '#')
//        //推荐这样写
//        if('#'== c)
//        {
//           // break;//跳出循环
//            continue;//跳出结束本轮（一次）循环
//            //输入abc#123     //输出就是abc123
//         //continue  本轮结束后，还是返回到if那句话
//        }
//        putchar(c);//输出
//    }
//    printf("\nbreak out!\n");
//    system("pause");
//    return 0;
//}


//伪代码：

//int main()
//{
//    do
//    {
//        printf("hello\n");
//        if (flag)
//        {
//            continue;
//            //这里continue;完了之后，到while()那一行
//        }
//    } while (cond);
//    return 0;
//}


//for (; i < ? ? ;)
//{
//    printf("hello world\n");
//    if (flag)
//    {
//        continue;
//        //这里的continue完了之后，是到if这一行
//    }
//}


//continue是条件判定在哪里，就会往哪里跳转


//#include <Windows.h>
//int main()
//{
//    int i = 0;
//    for (; i < 10; i++)
//    {
//        printf("continue before\n");
//        if (i == 5)
//        {
//            printf("continue\n");
//            continue;//这里就会发现这里的cotinue是到i++处，不是到i<10处
//        }
//        printf("continue after\n");
//        Sleep(500);//睡眠500毫秒，打印出来的时候会看到是一对一对打印出来的
//    }
//    return 0;
//}

//结论：
//continue   while   do..while 循环    会转跳到条件判定处
                       //   for循环  是会跳转到条件更新处


//循环语句注意点：
  //1、在多重循环中，如果有可能，应当将最长的循环放在最内层，最短的循环放在
// 最外层，最短的循环放在最外层，以减少CPU跨切循环层的次数
  //2、建议for语句的循环控制变量的取值采取“半开半闭区间”写法[6,10)
//循环次数明确，便于进行个数计算
  //3、循环要尽可能的短，要代码清晰，一目了然
  //4、把循环嵌套控制在3层以内
  //5、for语句的控制表达式不能包含任何浮点类型的对象
//因为浮点数在判定的时候可能就会有一些精度损失，影响判定的正确性，但不是绝对的
//但是for循环是控制变量次数的，所以一般不会用到浮点数



//10、goto语句
    
    //goto关键字能做什么呢？
  //以灵活性著称，可能会导致执行分支不明确，所以在很多的公司的编码规范中会禁止使用goto语句
    //是为了禁止一些能力不强的程序员使用它。
//int main()
//{
//    goto end;//直接从goto语句这里跳转到后面标签所对应的位置处
//    printf("hello 1\n");
//    printf("hello 2\n");
//    printf("hello 3\n");//这三行代码直接跳过
//    end:
//    printf("hello 4\n");
//    printf("hello 5\n");
//    printf("hello 6\n");
//
//
//    system("pause");
//    return 0;
//}//这是往下跳转


//int main()
//{
//    end:
//    printf("hello 1\n");
//    printf("hello 2\n");
//    printf("hello 3\n");
//    goto end;
//    printf("hello 4\n");
//    printf("hello 5\n");
//    printf("hello 6\n");
//    system("pause");
//    return 0;
//}//这是往上跳转
////这就变成了死循环，这是用goto语句简单实现了一个死循环（跳到end，又到goto end，又到end，一直这样
//                                                      //不停的跳转）


//int main()
//{
//    int i = 0;
//start:
//    printf("[%d] goto running...\n", i);
//    i++;
//    if (i < 10)
//    {
//        goto start;
//    }
//    printf("goto end...\n");
//    system("pause");
//    return 0;
//}


//void fun()
//{
//start:
//    printf("enter fun()\n");
//}
//int main()
//{
//    int i = 0;
//    printf("[%d] goto running...\n", i);
//    i++;
//    if (i < 10)
//    {
//        goto start;
//    }
//    printf("goto end...\n");
//    system("pause");
//    return 0;
//}//这样子是不行的 goto语句只能在本代码块中进行使用，不能跨代码块进行使用，所以goto语句不能进行
//    //文件操作的使用


//建议：
  //禁止使用goto语句
    //自从提倡结构化的设计以来，goto就成了有争议的语句。首先，由于goto语句可以灵活的跳转，
     //如果不加限制，它的确会破坏结构化设计风格；其次，goto语句经常带来错误或隐患，它可能跳过
     //了变量的初始化、重要的计算等语句。

//goto语句有人用吗？  
  //Linux内核源代码中充满了大量的goto，只能说我们目前，或者很多公司的业务逻辑不是那么复杂
  //在大型项目中，会用到了很多的goto语句，goto语句用的还是比较频繁的



//11、void关键字


//11.1

//int main()
//{
//    //void x;//不能定义变量的
//    //   //为什么void不能定义变量:因为不会给它开辟空间
//
//    //程序测试：
//    printf("%d\n", sizeof(void));//编译出来是0，证明其不给它分配空间
//    return 0;
//}//在Linux中void的大小是1

//void本身就被解释为空类型，强制的不允许定义变量

////void不能实现强转
//int main()
//{
//    int a = (void)10;//这是错误的，不能用void进行强制类型转化
//    return 0;
//}


//11.2 void修饰函数返回值和参数


//11.2.1 void修饰函数的返回值

//void test()
//{
//    printf("hello world\n");
//    return 1;
//}
//int main()
//{
//    test();//这样是正确的
//    int a = test();//这样就不对，返回值起作用了
//    return 0;
//}


//函数可以不写返回值吗？？
//答案是可以的，编译器是可以编译过的
//test()
//{
//    printf("hello world\n");
//    return 1;
//}
//int main()
//{
//    test();//这样是正确的
//    int a = test();//这样就正确了，需要上面函数不写返回值
//    return 0;
//}


//C中函数可以不带返回值，默认的返回值是：int
//这样的话，没有返回值可以不写吗？：不行，没有返回值，尽量要用void的形式写上
//不写返回值，可能会引起别人的误解，所以不要返回值，就用void来代替，代替之后，不能用int型来接收，一旦接收就是错误的
//void是不会让返回值保存起来的

//void修饰函数的返回值：
  //1、占位符，让用户明确不需要返回值
  //2、告知编译器，这个返回值无法接收



//11.2.2 void作为函数参数的场景

//int test1()
//{
//    return 1;
//}
//int test2(void)
//{
//    return 1;
//}
//int main()
//{
//    test1(1, 2, 3, 4);//这个函数虽说没有带函数参数，但是是会进行传参的，意思就是形式上走了一遍
//    test2(1, 2, 3, 4);//还是可以编译过的，但是在test2(void)中，void表示这个函数不需要进行传参，在VS2013中，参数
//                      //进行传参之后会直接报错
//    int a = test1();
//    printf("%d\n", a);
//    return 0;
//}

//void充当函数的形参列表：告知用户或者编译器，该函数不需要进行传参
//在Linux中就直接报错
//结论：如果一个函数没有参数，将参数列表设置成void，是一个不错的习惯，因为可以将错误明确提前发现
  //另外，阅读你代码的人，也一眼能看出，不需要参数。相当于“自解释”。


//11.3 void指针


//int main()
//{
//    void* p = NULL;//正确，说明void不能定义变量，void*可以定义变量
//                  //原因是因为void*是指针，它的大小在平台之中是明确的,32位就占4个字节，64位就占8个字节
//    return 0;
//}

//void* 

//int main()
//{
//    void* p = NULL;
//    double* x = NULL;
//    int* y = NULL;
//    x = p;
//    y = p;
//    //这里两边的类型是不相同的，但是编译器不给报错，甚至连个警告都是没有的
//    
//    p = x;
//    p = y;
//    //这里也是同样的
//    return 0;
//}
//原因是：void* 有一个经典的用法，可以被任何类型的指针接收
      //  void*                   可以接收任意指针类型     （非常常用）


//例子：
  //在库，系统接口的设计上，通常将接口设计成通用接口，既可以操作整型，也可以操作浮点类型，也可以操作数组



//void*能进行对应的指针运算吗？

//int main()
//{
//    int* p = NULL;
//    p++;
//    p--;
//    //整型指针是可以进行指针运算操作的
//    void* x = NULL;
//    x++;
//    x--;
//    //这里就不能进行了
//    //原因是：对指针进行运算，通常是衡量一个指针，向前或者向后类型长度的问题
//           //移动的是sizeof(void*)的长度，这个长度是0，所以不能进行运算，
//           
//    return 0;
//}

//在Linux之中，void*的大小是1，所以在Linux中是可以进行指针运算的
     //Linux中(sizeof(void*))的大小是1，所以可以进行加减


//补充内容：
  //GNU计划：又称革奴计划，是由Richard Stallman(理查德・斯托曼)在1983年9月27日公开发起的。它的目标是创建一套完全
   //自由的操作系统。他在编写Linux的时候自己制作了一个成功 GNU C标准。ANSI美国国家标准协会，它对C做的标准ANSI 
   //C标准后来被国际标准协会接收成为 标准C 所以ANSI C和标准C是一个概念，总体来说现在Linux也支持标准C，以后标准C可
   //以跨平台，而GNU C一般只在Linux C下应用。

//Linux上可用的C编译器是 GNU C 编译器，它建立在自由软件基金会的编程许可证的基础上，因此可以自由发布。
  //GNU C对标准C进行一系列扩展，以增强标准 C 的功能

//一句话：大部分编译器是标准C ，而Linux下是扩展C，Linux平台也能保证标准C的运行



// void* 指针可以直接解引用吗
//int main()
//{
//    //void* p = NULL;
//    //*p;
//    int a = 10;
//    void* p = &a;
//    *p = 20;
//    //这是不对的
//    return 0;
//}//原因是p是void*类型的指针，*p是对p进行解引用操作，解出来的类型就是void，就无法通过void进行查看里面的空间
//                                                                            //或里面的数据
//然后就报错了

//结论：C语言中，不能对void*类型的指针进行解引用



//关键字  ――――  第七讲

//本章重点：
  //汇编角度理解return的含义
  //const的各种应用场景
  //volatile的基本理解与实验证明


//12、return 关键字

//#include <windows.h>
//char* show()
//{
//    char str[] = "hello bit";
//    return str;
//}//这里本质上是一份临时空间
////在函数调用的时候是在栈上开辟的空间，函数调用完毕后，这个栈结构就会被释放掉
////所以局部变量是具有临时性的
//int main()
//{
//
//    char* s = show();
//    printf("%s\n", s);
//    system("pause");
//}//编译出来是乱码

//C语言有没有真正意义上的字符串类型的？
//C语言没有字符串类型，但是C语言是有字符串的，这是两种不同的概念

//什么语言是有字符串类型的：（string类型）
  //Java，C++，


//字符串类型VS字符串
//计算机中如何理解删除数据？

//计算机中释放空间是否真的要将我们的数据全部清0/1？
  //计算机中清空数据，只需要设置该数据无效即可（并不是将数据删除，而是将数据设置成无效）

//char* show()
//{
//    char str[] = "hello world";
//    return str;
//}//这里本质上是一份临时空间
//////在函数调用的时候是在栈上开辟的空间，函数调用完毕后，这个栈结构就会被释放掉
//////所以局部变量是具有临时性的
//int main()
//{
//    char* s = show();
//    printf("%s\n", s);//调试到这里的时候，指向的代码就直接成无效代码了
//    system("pause");//当调用完printf的时候，hello world就不复存在了，printf调用前，hello world是存在的
//                     //原因是printf也是函数，就要遵守规则：就要形成栈帧，返回printf就要释放栈帧，就可能会覆盖
//                                                       //原来的数据区域可能printf的栈帧区域更大，就会覆盖show函数
//                                                       //留下来的栈帧结构数据
//    return 0;
//}
//与上面的代码相同，
//如何理解栈帧销毁，计算机中所谓的删除数据究竟是在做什么？
//函数调用，调用的时候，就要在在内存中开始申请空间。

//在C程序中，地址空间会被划分成以下几块：从下到上：上面为高地址，下面是低地址
//从下到上依次递增的：代码区，字符常量区（静态常量区），已初始化全局数据区，未初始化全局数据区，
// 堆区，栈区，堆栈相对而生的，堆区向增长，栈区向下增长（地址减小方向增长的）

//栈区：main函数：当在main函数中定义变量的时候，系统就会在栈中给main函数中开辟空间的区域给变量进行开辟空间（二次开辟）
  //栈中给main函数开辟的区域叫做栈帧结构，（也可叫main函数的栈帧）
  //然后在main函数栈帧下进行开辟show函数的空间，所以叫做show函数的栈帧
  //如果show函数内部也有函数调用，则会在show函数向下继续开辟空间，每一个大的结构都叫做栈帧结构
     //（对于上面的代码来表示，会在show栈帧内部进行开辟一个数组的空间，将字符串放进去）
//调用函数，形成栈帧
//函数返回，释放栈帧
  //将该栈帧释放掉，是不是将该栈帧内部的数据清空？：不会
                  //会不会将内部的数据进行修改呢？：不会
    //所以，在show函数调用完成后，s指向的内容是不会消失的，所以s指向的内容依旧在
//重点：无效而不是删除


  //为什么临时变量具有临时性？
     //因为栈帧结构在函数调用完毕，需要被释放，所有的临时变量都是在栈帧结构中开辟空间，所开辟的空间最终都会被释放


  //推荐：规则：return语句不可反悔指向“栈内存”的“指针”。因为该内存在函数提结束时被自动销毁。

//int GetData()
//{
//    int x = 0x11223344;
//    printf("run get data!\n");
//    return x;
//}
//int main()
//{
//    int y = GetData();
//    printf("ret:%x\n", y);
//    system("pause");
//    return 0;
//}
//x变量是临时变量，为何主函数可以拿到这个值吗？（这个要研究到汇编语言中）//eax是寄存器的通用语言
  //从汇编语言中可以看到：通常函数是通过寄存器的方式，返回给函数调用方！！
    //高级语言写完之后，系统就会自动生成汇编语言，有没有用不知道，反正汇编系统会自己自觉的生成汇编语言

//问题：一般的函数return 是返回到调用方的，main函数的返回值返回给谁了？？
  //这个问题会后面来讲，因为涉及到了操作系统


//13.const 关键字也许应该被替换为 readonly
 
  //13.1  const修饰的只读变量

//int main()
//{
//    //int a = 10;//给a进行开辟空间，变量名就是a，变量中进行10的赋值
//    //a = 20;//对a进行二次赋值
//    const int a = 10;//加上const之后表明该a变量不可 直接 被修改
//    //a = 20;//这样就叫做直接修改
//    
//    //const可以出现在类型之前，也可以出现在类型之后，但是建议是放在类型前面
//    system("pause");
//    return 0;
//}

//int main()
//{
//    //int a = 10;
//    //int* p = &a;
//    //printf("before:%d\n", a);
//    //*p = 20;
//    //printf("after:%d\n", a);
//
//    ////这里定义了两个变量，第一个变量是a，a中放的是int类型的，第二个变量是*p,(指针变量)，里面放的是a的地址
//    ////*p这里是进行的解引用操作，解引用是指 指针p所指向的目标，所以*p就是a
//    
//    
//    
//    const int a = 10;
//    //int* p = &a;//这里会出现一个警告，两边的类型不同。所以进行强制类型转换一下即可
//    int* p = (int*)&a;
//    printf("before:%d\n", a);
//    *p = 20;
//    printf("after:%d\n", a);
//    //这里就可以进行将const修饰的值改变，通过指针进行间接改变
//    system("pause");
//    return 0;
//}

//结论：const修饰的变量并非是真的不可被修饰的常量
//那const修饰变量，意义何在？
  //1、让编译器进行直接修改式检查
  //2、告诉其他程序员（正在改你代码或者阅读你代码的）这个变量后面不要改哟。也属于一种“自描述”含义



//int main()
//{
//    char* p = "hello world!\n";
//    *p = "H";
//    //这里系统就是就会崩溃，编译的时候写入位置时会发生访问冲突，也就是越界访问
//    //这里就是系统约束，不让直接写入，这里的“hello world！”，就是真正意义上的不可以被修改
//    //并不是C语言提供的，而是操作系统级别上为代码进行的保护、
//    //再往深的说就是操作系统上的事了，所以要了解操作系统关于这块的处理
//    system("pause");
//    return 0;
//}

//const价值 并不是在运行期间保护代码不可读，而是在运行期间保护我们的数据不可被修改、

//int main()
//{
//    const int n = 10;
//    int arr[n];//这份代码是编译不过的
//    //但是在Linux中可以编译过
//    return 0;
//}
//一份代码可能在不同的编译器下会出现不同的结果，所以在写代码的过程中尽可能的进行标准C的书写，因为标准C是
  //所有编译器都可以编译过的，所以 标准C 的代码具有跨平台性


//13.2  const修饰一般变量
  //一般变量是指简单类型的只读变量。这种只读变量在定义时，修饰符const可以用在类型说明符前，也可以用在类型说明符后。

//13.3  const修饰数组
  //定义或说明一个只读数组
//const int arr[] = { 1,2,3,4,5 };
////arr[0] = 0;
////arr[1] = 0;
////arr[2] = 0;
////arr[3] = 0;
////arr[4] = 0;
//////上面就是不对的，只能是只读数组


//13.4 修饰指针

//首先引入两个概念：
    //指针和指针变量
//int main()
//{
//    int* p;
//    //指针是一个地址
//    //指针变量是一个变量，这个变量用来保存地址
//
//    //宿舍楼为何要有门牌号，意义是什么？
//       //提高查找定位效率！！
//    //楼相当于内存，访问内存的基本单位是字节，一个字节是有八个比特位的，一个字节相当于宿舍，同学相当于比特位
//      //包工头带着李四找宿舍楼中的某个位置，包工头相当于CPU，李四就相当于CPU中的代码，当CPU进行内存寻址的时候，
//       //当没有门牌号的时候，查找的效率就会非常非常低，为了提高效率，便给内存带上了一个结构：编址结构
//    //这每个都有一个地址信息，这就是指针
//    //地址就是指针
//    
//    //为什么要有指针：通过指针，可以提高CPU在内存空间中的查询效率
//    //什么是指针：指针就是地址
//
//    //地址是数据吗？？
//      //地址肯定是数据呀
//
//    //那么数据可以被保存吗？
//    //边址空间中的每一个小格子都代表着一个个的 指针变量
//
//
//    return 0;
//}



//int x;          
//x = 100;        //x的空间，变量的属性  (左值)
//int y = x;      //x的内容或者数据的属性 （右值）


//重点是：
//任何一个变量名，在不同的应用场景中，代表着不同的含义！！！


//int a = 10;
//
//int* p = &a;
//p = &b;  //p指针变量的空间，代表着指针变量 ，这是左值              （左值，使用的是变量的空间）
//q = p;   //p代表着p里面的内容，代表着p内部的保存数据，这是右值     （右值，使用的是变量的内容）
             //p的内容，也就是地址！


//指针和指针变量
  //指针就是地址，指针变量就是变量，里面保存的是地址数据


//int a = 10;
////定义一个a的变量，类型是int，a变量中放的是10；
//
//int* p = &a;
////这是定义一个p的指针变量，类型是int* ，p的指针变量里面放的是&a的值，也就是地址，指向a的地址

//&a,取地址，取那个地址，取地址最低的那个！！

//在C语言中，任何变量取地址都是从最低地址开始的！！！

//一般认为是从左侧开始，这是默认的，左侧也就是低地址处


//铺垫完成，正式开始const修饰指针



//int main()
//{
//    int a = 100;
//    int* p = &a;
//    *p = 100;  //*p就是a，将a的值改成100
//    p = 100;   //p指向的是地址为100的变量
//    return 0;
//}


//1、
//int main()
//{
//    int a = 10;
//    
//    //const修饰*  
//
//    const int* p = &a;//不是const修饰的p无法改变，而是p所指向的内容无法改变
//              //p指向的变量不可以直接被修改
//    //*p = 100;//这个是不可以的（const修饰* 所以*p不可以改）
//    p = 100;//但是const没有修饰p，所以这行代码是可以的
//    system("pause");
//    return 0;
//}

//关键字是不能修饰关键字的，但是呢，对于这个来说 const不是修饰int 这个修饰的是*,所以这两个是可以在一起的


//2、
//int main()
//{
//    int a = 10;
//    int const* p = &a;//这样也可以，但是呢，通常是将const放在int的前面
//       //这两组效果是一样的，没有什么大的差异，const是修饰* 的，*p不可用，p可以用
//    *p = 100;
//    p = 100;
//    system("pause");
//    return 0;
//}


/*const int* p;
int const* p;*/  //这是一组


//3、
//int main()
//{
//    int a = 10;
//    int* const p = &a;
//       //const 修饰的是p变量，const前面代表类型
//       //代表p的内容不能直接被修改 p的指向不能被修改
//    //所以p=100不可以，*p=100就可以
//    *p = 100;
//    p = 100;
//    system("pause");
//    return 0;
//}



//4、
//int main()
//{
//    int a = 10;
//    const int* const p = &a;
//         //这个就是const首先修饰*     ，    const再修饰p
//       //所以*p和p都不能直接被改变
//    *p = 100;
//    p = 100;
//    system("pause");
//    return 0;
//}


//int main()
//{
//    const int a = 10;
//    int b = a;//这里是可以编译过的，const修饰的a，a不能被改变，但是又不是不能被赋值
//    return 0;
//}


//int main()
//{
//    int a = 10;
//    //const int* p = &a;//警告： 不同的“const”限定符
//    int* const p = &a;//这样就没有警告了
//    int* q = p;
//    system("pause");
//    return 0;
//}

//这两个可以对照着看



//int main()
//{
//    int a = 10;
//    int* p = &a;
//
//    //const int* p = &a;//这是有警告的
//
//    const int* q = p;//但是这样写就没有警告了
//       //有一个小经验：
//       //一般，如果把一个类型限定并不怎么严格的变量，赋给类型限定很（非常）严格的变量这是不报错的
//       //如果把一个类型限定比较严格的变量赋给一个类型限定不怎么严格的变量，编译器就会报错
//            //就相当于将一些严格的地方放在了不严格的地方，所以后面可能就会出现一些未知的错误
//    return 0;
//}



//13.5   const修饰函数
 
  //13.5.1  const修饰函数的参数


//void show(int* _p)
//{
//    printf("value:%d\n", *_p);
//}


//void show(const int* _p)//这样修饰的话就是保证不让人直接在函数内部直接做修改
//{
//    printf("value:%d\n", *_p);
//    printf("show_P:%p\n", &*_p);
//    //*_p = 20;//这就直接错误，这是一种预防性编程的一种措施，编译器会直接报错
//}
//int main()
//{
//    int a = 10;
//    int* p = &a;
//    printf("main:%p\n", &p);
//          //这两个地址是完全不同的
//
//    show(p);//这里调用show传参有没有形成临时变量？？
//            //C语言中，任何函数传参都一定要形成临时变量，包含指针变量
//    return 0;
//}

  //13.5.2  const修饰函数的返回值

//const int* GetVal()
//{
//    static int a = 10;
//    return &a;
//}
//int main()
//{
//    //int* p = GetVal();//这里有一个警告：不同的“const”限定符
//    const int* p = GetVal();//这里就没有问题，没有出现警告
//    //*p = 100;//编译器直接报错，达到了我们得目的，不想让一个指针通过返回值的方案 来修改一个函数内部的变量 
//                 //这样一个概念
//    return 0;
//}

//一般在内置类型返回，加const无意义




//14.最易变的关键字  --  volatile

   //volatile 关键字和const 一样是一种类型修饰符，用它修饰的变量表示可以被某些编译器未知的因素更改
       //比如操作系统、硬件或者其他线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，
       //从而可以提供对特殊地址的稳定访问

//编译器会自动对代码进行一定的优化
   //编译器优化了之后文件会相对的变大

//volatile  常用在多线程的任务中
  //所以这个关键字是不希望被编译器优化，达到稳定访问内存的目的

//这部分在VS中测试这个效果不是非常的明显，所以这个在Linux中进行测试比较好


//const要求你不要进行写入就可以，volatile意思是你读取的时候，每次都要从内存中读，两者并不冲突
  //虽然volatile就叫做易变关键字，但这里仅仅是描述它修饰的变量可能会变化，要编译器注意，把那个不是它要求对应
  //变量必须变化！这点要特别注意。





//关键字    ----    第八讲


//本章重点：
  //exter在多文件下的理解与使用
  //struct关键字的理解和柔性数组
  //union的内存级布局理解
  //enum关键字的基本理解
  //typedef的理解和分类
  //关键字总结



//15.最会帽子的关键字 - extern

  //多文件测试
  //extern 声明变量
  //extern 声明函数




//16.struct 结构体

//#define NUM 64
//struct stu
//{
//    char name[NUM / 2];
//    int age;
//    char sex;
//    char addr[NUM];
//}a, b, c;
////定义结构体，本质是在制作类型
////后面的abc相当于int a ; int b , int c
////相当于给  a  定义一个类型
//
//int main()
//{
//    //struct stu zhangsan;
//         //C语言中 struct stu 称作类型
//         //C++语言中 struct stu 称为类
//    //struct stu lisi;
//
//    struct stu x = { "zhangsan",19,'man',"地球" };
//    //x = { "zhangsan",19,'man',"地球" };
//  //这个就是错的，说明结构体整体是可以进行初始化，不能被赋值，要赋值的话，只能一个一个进行赋值，这时就要进行
//     //一个结构体内部元素的访问
//  //这就是在用指针是箭头操作符（->），用平常的就是点操作符（.）
//  //对于数组来说，只能被初始化，要是想赋值的话，不能直接用等号，而是得用strcpy这个函数
//
//
//    struct stu* p = &x;
//    //这里是用得是struct stu指针，（结构体指针，p叫做结构体指针变量），指针里面要放的是地址，所以要进行&x
//    //加入x是个200字节大小，所以取地址取的是200个地址，那么，这个&地址取的是哪个地址？？
//                                                //答案是：在数字层面上，这个结构体开辟的地址值最小的那个
//    printf("%s\n", (*p).name);//这里不能是 *p.name
//    //或：
//    printf("%s\n", p->name);   //这里不能是 *p->name
//    system("pause");
//    return 0;
//}

//为什么结构体访问的时候会有两种访问方式
  //C语言是一个面向过程的语言，面向过程最重要的是函数，只要有函数就得传参，传参就会形成临时拷贝，一个结构体可能贯
    // 穿多个函数，传的是指针的话，用指向操作符就比较方便，所以就很有必要给结构体设置一个单独的访问方式


//16.1
  //空结构体有多大？
    

//#define NUM 64
//struct stu
//{
//};
//int main()
//{
//    printf("%d\n",sizeof(struct stu));
//    system("pause");
//    return 0;
//}

//在VS编译器中：
//这样空结构体是不正确的
  //要求一个结构或者联合至少有一个成员，也就是C语言中不能有空结构体，而是在C++中，空结构体可以编译过去

//在Linux中：gcc编译器是可以进行空结构体的编译，编译出来的结构体大小是0

//这里空结构体中的编译是根据编译器的不同而有所不同


//16.2   柔性数组
    //1、柔性数组的定义  2、柔性数组的使用

//要求：必须放在结构体内部

//struct stu
//{
//    //int arr[0];//这样是可以编译过去的
//    //一般情况下的编写规范：
//    char num;
//    //.....
//    int arr[0];//是将柔性数组放在最后一个
//    //C99所引用的一种标准
//};
//int main()
//{
//    //struct stu zhangsan;
//    
//    //printf("%d\n", sizeof(sizeof(struct stu)));//编译出来是4，因为只有一个整型，柔性数组是不占对应空间的
//
//
//    //开辟空间：
//    struct stu* p = malloc(sizeof(struct stu) + sizeof(int) * 10);
//        //这个是在申请struct stu 这部分内存之后，还紧接着申请10个int型的空间 
//      //前面的结构体在内存中的占位就是在前面，也就是低地址处，后面是在前面的地址的位置接近着就是下面的位置
//    p->num = 10;
//    for (int i = 0; i < p->num; i++)
//    {
//        p->arr[i] = i;
//    }
//    free(p);
//    return 0;
//}
////申请下空间最后都会出现一些没用到的空间，这部分空间是给柔性数组使用的



//17. union 关键字
  //基本认识和补充认识
     //体系结构认识：CPU访问的基本单位事：字节
     //一个整形有四个字节，取地址的时候，取的是哪一个字节呢？
     //     取的是地址最低的那个
     //哪又如何完整读取一个整形呢？谁起的作用？
     //   拿到的永远都是地址的起始地址  类型决定（起作用）
     //union的内存布局 
  


//union un
//{
//    int a;
//    char b;
//};
//int main()
//{
//    union un x;
//    printf("%d\n", sizeof(union un));//输出为4
//    printf("%p\n", &x);
//    printf("%p\n", &(x.a));
//    printf("%p\n", &(x.b));
//    
//    return 0;
//}//a和b是共用空间的，空间大小是所对应的大小是用最大的来计算
//联合体也是自己创建的类型，与结构体是相同的，可以用点操作符
  //在联合体中，如果在内存分配中，会将联合体的第一个元素放在低地址处还是高地址处？？
   //下面三个打印出来的是一样的地址
   //联合体内：所有成员的起始地址都是一样的！！！
//b永远在a的低地址处，每一个都是第一个元素


//union un
//{
//    int a;
//    char b;
//};
//int main()
//{
//    union un x;
//    x.a = 1;
//    //这里的1转换成16进制就是0x 00 00 00 01
//    //同时在内存开辟中开辟4个空间的大小
//    //在放进去的时候，就会出现两种方法：
//    //方法一：
//       //将低权值位放置到低地址处   叫做小端（小小小）
//       // 00 00 00 01  但是b永远都在a的低地址处，所以b所对应的就是01
//    //方法二：
//       //将低权值位放置到高地址处   叫做大端（小大大）
//       // 01 00 00 00 所以b所对应的就是00
//    if (x.b == 1)
//    {
//        printf("小端\n");
//    }
//    else
//    {
//        printf("大端\n");
//    }
//    return 0;
//}
////现在的计算机绝大部分都是小端机


//17.1  大小端
   //大小端是对空间的布局是没有关系的，
     //对在union中存数据是有影响的，大小端本质是一个数据存储的解决方案


//union un
//{
//    int a;
//    char b[5];
//};
//int main() 
//{
//    printf("%d\n", sizeof(union un));
//    return 0;
//}
////问：这个联合体的大小是多少？
//  //答案是8，
////联合体也得严格遵循内存对齐
////最大的是5，整除4的最小就是8

//union un
//{
//    int i;
//    char a[2];
//}*p, u;
//int main()
//{
//    p = &u;
//    p->a[0] = 0x39;
//    p->a[1] = 0x38;
//    p->a[2] = 0x37;
//    p->a[3] = 0x36;
//    printf("%x\n", p->i);
//    //排放的时候，是从低地址处开始排放，36的地址处要比39的地址处要高
//    //但是在打印的时候是从高地址处开始打印，所以打印出来的是36373839
//    return 0;
//}



//18. enum 关键字
   //很多初学者对枚举（enum）感到迷惑，或者认为没什么用，其实枚举是个很有用的数据类型 
    //枚举的作用是枚举一堆的常量
//enum color
//{
//    RED,
//    YELLOW,
//    BLACK,
//    GREEN,
//    BLUE
//    //枚举常量是枚举内部的这些常量可以直接当一组数据来使用
//};
//int main()
//{
//    enum color c = RED;//这里是定义变量没有初始化的行为，这里并没有警告
//       //说明左右两边的类型是一样的，所以枚举类型可以等价于我们前面的整型
//    printf("%d\n", RED);
//    printf("%d\n", BLUE);
//
//    return 0;
//}

//为什么要存在枚举这个关键字？
    //枚举具有代码的自描述性
       //所有常量的常量名 不是数字而是单词
//那宏也有自描述性，这是对的，因为定义宏的话，是使用的常量比较少，要是多的话，就用到枚举了


//更改枚举的值就直接在枚举关键字中进行更改就行了，例如：
//enum Color
//{
//    RED = 10,
//    YELLOW,
//    BLACK = 100,
//    BLUE
//};
//
////这样的话YELLOW就是11，BLUE是101



//关键字    ----    第九讲    结束操作符


//19.typedef 关键字
// 
// 19.1 历史的误会――也许应该是typerename 
// 
  //typedef 其实就是一个含义：类型重命名
  //1、对一般类型进行重命名
  //2、对结构体类型进行重命名
  //3、对指针进行重命名
  //4、对复杂结构进行重命名

//typedef unsigned int u_int;
//typedef int* int_p;
//
//typedef struct stu
//{
//    char name[16];
//    int age;
//    char sex;
//}stu_t;
//
//typedef int a[10];//可以这样子来写，那a是数组还是a数组类型
//
//int main()
//{
//    stu_t s;
//    u_int x = 0;
//    int_p p = NULL;
//    a b;//这里b也是所对应的一个数组，上面定义完之后应该就不能理解成数组，严格可以理解成数组类型
//    return 0;
//}


//19.2 typedef 与#define 的区别

////问题1：
//typedef int* ptr_t;
//ptr_t p1, p2;
////问：p1,p2 分别是什么类型呢？
//  //都是int* 类型的
//     //下面有解释
//
//#define PTR_T int*
//PTR_T p1, p2;
////问：p1,p2分别是什么类型的呢？
//    //p1的类型为int* 而p2的类型为int
//      //下面有解释
//
////问题2：下面关于typedef部分的代码对吗？？
//#include <stdio.h>
//#include <windows.h>
//
//#define INT32 int 
//typedef int int32;
//int main()
//{
//    unsigned INT32 a;//这里是正确的，而且类型为unsigned int 
//    unsigned int32 b;//这里就会直接报错
//    //用typedef 重新定义的新类型不能重新配上其他的类型进行充当一个整体的类型
//      //有点像 int char a;
//    return 0;
//}


//typedef int* int_p;
//int main()
//{
//    //int* a, b;
//    ////这样的话就是a与int* 离的相对比较近，所以编译器就会认为a是int* 型的
//    //                                         //    但是呢， b是int  型的
//    ////可以在监视中检测到
//
//    ////但是为什么呢？？
//    ////语法是这么规定的，a是指针，b是系统默认的int类型
//
//    int* a = NULL, b = 0;//这样子可以吗？？
//    //编译器还是一样的,a的类型是int* b的类型是int
//    
//    int_p a, b;
//    //此处a和b各是什么类型？
//      //两个都是int* 了
//    
//    //应该将int_p理解成一种全新的类型，就不存在与*号的优先级的关系，与其后的所有变量全部都有效
//    return 0;
//}

//#define ptr_t int* 
//int main()
//{
//    int* a, b, c;
//    ptr_t a, b, c;
//    //问：此处，编译器能否编译通过？？且a,b,c各自是什么类型？？
//       //当是类型重命名，并不是类型替换，相当于形成一个全新的类型，独立的，与double,float是无差别的
//    //编译之后出现的是a的类型为int* ,而b,c 的类型为int ，所以下面的和上面的可以相互等价
//    //这里#define 可以理解成   替换成
//    return 0;
//}

//typedef static int int32_t     //行不行
//    //这样一看，果真不行，
//    //原因：指定了一个以上的存储类
//      //这个问题要交代清楚，要弄清下面这些事：

//目前，我们已经将c89（c90）的所有关键字去拿不学完，下面对关键字进行一下分类，方便大家理解：

//数据类型关键字（12个）
  //char :声明字符型变量或函数
  //short:声明短整型变量或函数
  //int  :声明整型变量或函数
  //long :声明长整型变量或函数
  //signed:声明有符号类型变量或函数
  //unsigned:声明无符号类型变量或函数
  //float :声明浮点型变量或函数
  //double:声明双精度变量或函数
  //struct:声明结构体变量或函数
  //union :声明共用体（联合）变量或函数
  //enum  :声明枚举类型
  //void  :声明函数无返回值或无参数，声明无类型指针

//控制语句关键字（12个）
  //1、循环语句（5个）
    //for:一种循环语句
    //do ；循环语句的循环体
    //while:循环语句的循环条件
    //break:跳出当前循环
    //continue:结束当前循环，开始下一轮循环

  //2、条件语句（3个）
    //if  :条件语句
    //else:条件语句否定分支
    //goto:无条件跳转循环
  
  //3、开关语句（3个）
    //switch :用于开关语句
    //case   :开关语句分支
    //default:开关语句中的“其他”分支

  //4、返回语句（1个）
    //return:函数返回语句（可以带参数，也可以不带参数）

//存储类型关键字（5个）
  //auto：声明自动变量，一般不使用
  //extern：声明变量是在其他文件中声明
  //register:声明寄存器变量
  //static:声明静态变量
  //typedef:用以给数据类型取别名（但是该关键字被分到存储关键字分类中，虽然看起来没什么相关性）
        
      //多说几句：存储关键字，不可以同时出现，也就是说，在一个变量定义的时候，只能有一个。

  //其他关键字（3个）
    //const:声明只读变量
    //sizeof:计算数据类型长度
    //volatile:说明变量在程序执行中可被隐含地改变


                                        //                                 --32个关键字   完
